---
---
layout: post
title: "Python内存管理"
date: 2018-7-31 11:00:00 +0800 
categories: 酱油人生
tag: Python memory
---
* content
{:toc}

## 1. 对象VS引用
	python引用和对象分离；python使用变量不需要提前声明；
	a = 1 :a为引用，1为对象，即引用a指向了对象1，用id(a)可以获得对象的内存地址。
	a = "bbb" :a又指向了“bbb”，1不再有引用指向它，会被python内存处理机制当垃圾回收。
	a = 1,b = 1：a和b同时指向1。
	对象值改变，引用的地址也会改变：
	>>> L1 = [1,2,3]
	>>> L2 = L1
	>>> id(L1)
	139643051219496
	>>> id(L2)
	139643051219496
	>>> L1[0] = 10
	>>> id(L1)
	139643051219496
	>>> id(L2)
	139643051219496
	>>> L2


## 2. 浅拷贝VS深拷贝
	1）直接赋值,传递对象的引用而已,原始列表改变，被赋值的b也会做相同的改变

	2）copy浅拷贝，没有拷贝子对象，所以数据改变，子对象改变
	3）深拷贝，包含对象里面的自对象的拷贝，所以原始对象的改变不会造成深拷贝里任何子元素的改变

## 3. [内存释放](https://blog.csdn.net/nirendao/article/details/44426201)
	Python确实存在这么一个不释放内存的现象，然后提出一个解决方案，即：先del，再显式调用gc.collect(). 
## 4. [内存泄漏](https://www.linuxzen.com/python-nei-cun-xie-lu-shi-zhan-fen-xi.html)
	产生原因
		项目中两种情况导致对象没有被正确回收:
		被退出才回收的对象引用
		交叉引用
		日志使用不当导致


